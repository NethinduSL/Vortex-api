<script>
    // Get URL parameters
    const urlParams = new URLSearchParams(window.location.search);
    const gameId = urlParams.get('gameId');
    const username = urlParams.get('username');
    
    // Game state variables
    let currentState = null;
    let statePollInterval = null;
    let statusPollInterval = null;
    let joinAttempts = 0;
    const maxJoinAttempts = 10;

    // Safe DOM element access
    function getElement(id) {
        const element = document.getElementById(id);
        if (!element) {
            console.warn(`‚ö†Ô∏è Element not found: ${id}`);
        }
        return element;
    }

    function safeTextContent(element, text) {
        if (element) {
            element.textContent = text;
        }
    }

    function safeInnerHTML(element, html) {
        if (element) {
            element.innerHTML = html;
        }
    }

    // Error handling
    function showError(message) {
        const errorElement = getElement('errorMessage');
        if (errorElement) {
            errorElement.textContent = message;
            errorElement.classList.remove('hidden');
        }
        console.error('‚ùå Game Error:', message);
    }

    function hideError() {
        const errorElement = getElement('errorMessage');
        if (errorElement) {
            errorElement.classList.add('hidden');
        }
    }

    // Initialize game when page loads
    document.addEventListener('DOMContentLoaded', () => {
        console.log('üöÄ Initializing Vortex Islands Game...');
        
        // Validate required parameters
        if (!gameId || !username) {
            showError('Missing game ID or username. Redirecting to lobby...');
            setTimeout(() => window.location.href = '/', 3000);
            return;
        }
        
        console.log('üéÆ Starting game:', { gameId, username });
        
        // Set initial player info
        safeTextContent(getElement('playerName'), `${username}'s Island`);
        safeTextContent(getElement('playerInfo'), `Player: ${username}`);
        
        // Start the game
        startGame();
    });
    
    function startGame() {
        joinGame();
        startStatusPolling();
        startStatePolling();
    }
    
    function joinGame() {
        if (joinAttempts >= maxJoinAttempts) {
            showError('Failed to join game after multiple attempts. Please try again.');
            return;
        }
        
        joinAttempts++;
        console.log(`üîó Join attempt ${joinAttempts} for game ${gameId}`);
        
        // Use the correct endpoint: /game-action/:gameId
        fetch(`/game-action/${gameId}`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ type: 'join', username: username })
        })
        .then(response => {
            if (!response.ok) {
                throw new Error(`Server returned ${response.status}`);
            }
            return response.json();
        })
        .then(data => {
            if (data.error) {
                throw new Error(data.error);
            }
            console.log('‚úÖ Successfully joined game');
            hideError();
            updateGameState(data.state);
        })
        .catch(error => {
            console.error('Join failed:', error.message);
            showError(`Join failed: ${error.message}. Retrying...`);
            setTimeout(joinGame, 2000);
        });
    }
    
    function startStatusPolling() {
        // Clear any existing interval
        if (statusPollInterval) {
            clearInterval(statusPollInterval);
        }
        
        statusPollInterval = setInterval(() => {
            fetch(`/game-status/${gameId}?username=${encodeURIComponent(username)}`)
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`Status error: ${response.status}`);
                    }
                    return response.json();
                })
                .then(status => {
                    updateConnectionStatus(status);
                })
                .catch(error => {
                    console.log('Status poll error:', error.message);
                });
        }, 2000);
    }
    
    function startStatePolling() {
        // Clear any existing interval
        if (statePollInterval) {
            clearInterval(statePollInterval);
        }
        
        statePollInterval = setInterval(() => {
            fetch(`/game-state/${gameId}`)
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`State error: ${response.status}`);
                    }
                    return response.json();
                })
                .then(state => {
                    if (state.error) {
                        throw new Error(state.error);
                    }
                    hideError();
                    updateGameState(state);
                })
                .catch(error => {
                    console.log('State poll error:', error.message);
                    showError(`Connection issue: ${error.message}. Retrying...`);
                });
        }, 3000);
    }
    
    function updateConnectionStatus(status) {
        const connectionElement = getElement('connectionStatus');
        if (!connectionElement) return;
        
        if (status.playersConnected === 2) {
            connectionElement.innerHTML = '‚úÖ <span>Connected - Game Ready!</span>';
            connectionElement.className = 'connection-status status-connected';
        } else if (status.playersConnected === 1) {
            connectionElement.innerHTML = '‚è≥ <span>Waiting for opponent to join...</span>';
            connectionElement.className = 'connection-status';
        } else {
            connectionElement.innerHTML = 'üîó <span>Connecting to game server...</span>';
            connectionElement.className = 'connection-status';
        }
    }
    
    function updateGameState(state) {
        currentState = state;
        
        // Update game phase
        safeTextContent(getElement('gamePhase'), `Phase: ${state.phase.toUpperCase()}`);
        
        // Update islands
        updateIslandDisplay('player', state.islands[username], state.scores[username]);
        const opponent = state.players.find(p => p !== username);
        if (opponent) {
            safeTextContent(getElement('opponentName'), `${opponent}'s Island`);
            updateIslandDisplay('opponent', state.islands[opponent], state.scores[opponent]);
        }
        
        // Update game log
        updateGameLog(state.moves);
        
        // Update controls based on game state
        updateControls(state, opponent);
        
        // Check for game over
        if (state.gameOver) {
            showGameOver(state);
        }
    }
    
    function updateIslandDisplay(type, island, score) {
        safeTextContent(getElement(`${type}Parts`), `Parts: ${island.parts}`);
        safeTextContent(getElement(`${type}Shields`), `Shields: ${island.shields}`);
        safeTextContent(getElement(`${type}Score`), `Score: ${score}`);
    }
    
    function updateGameLog(moves) {
        const logElement = getElement('gameLog');
        if (!logElement) return;
        
        logElement.innerHTML = '';
        
        // Show latest moves first
        moves.slice().reverse().forEach(move => {
            const message = document.createElement('div');
            message.className = 'log-message';
            message.textContent = move;
            logElement.appendChild(message);
        });
    }
    
    function updateControls(state, opponent) {
        const isMyTurn = state.turn === username;
        const isRPSPhase = state.phase === 'rps';
        const isActionPhase = state.phase === 'action';
        const isWinner = state.winner === username;
        const hasChosenRPS = state.pendingRPS && state.pendingRPS[username];
        
        // Show/hide phases
        const rpsPhase = getElement('rpsPhase');
        const actionPhase = getElement('actionPhase');
        if (rpsPhase) rpsPhase.style.display = isRPSPhase ? 'block' : 'none';
        if (actionPhase) actionPhase.style.display = isActionPhase ? 'block' : 'none';
        
        // Enable/disable RPS buttons
        const canChooseRPS = isRPSPhase && isMyTurn && !hasChosenRPS && state.playersConnected === 2;
        const rockBtn = getElement('rockBtn');
        const paperBtn = getElement('paperBtn');
        const officerBtn = getElement('officerBtn');
        if (rockBtn) rockBtn.disabled = !canChooseRPS;
        if (paperBtn) paperBtn.disabled = !canChooseRPS;
        if (officerBtn) officerBtn.disabled = !canChooseRPS;
        
        // Enable/disable action buttons
        const canTakeAction = isActionPhase && isMyTurn && isWinner && state.playersConnected === 2;
        const mortarBtn = getElement('mortarBtn');
        const shieldBtn = getElement('shieldBtn');
        const slicerBtn = getElement('slicerBtn');
        if (mortarBtn) mortarBtn.disabled = !canTakeAction;
        if (shieldBtn) shieldBtn.disabled = !canTakeAction;
        if (slicerBtn) slicerBtn.disabled = !canTakeAction;
        
        // Update status messages
        safeTextContent(getElement('playerStatus'), getStatusMessage(state, username, true));
        if (opponent) {
            safeTextContent(getElement('opponentStatus'), getStatusMessage(state, opponent, false));
        }
            
        // Highlight active islands
        const playerIsland = getElement('playerIsland');
        const opponentIsland = getElement('opponentIsland');
        if (playerIsland) playerIsland.classList.toggle('active', isMyTurn);
        if (opponentIsland) opponentIsland.classList.toggle('active', !isMyTurn && opponent);
    }
    
    function getStatusMessage(state, player, isSelf) {
        if (!player) return 'Waiting...';
        
        const isTheirTurn = state.turn === player;
        const hasChosenRPS = state.pendingRPS && state.pendingRPS[player];
        
        if (state.phase === 'rps') {
            if (isTheirTurn) {
                return hasChosenRPS ? '‚úÖ Choice made!' : 'üéØ Your turn - Choose RPS!';
            } else {
                return hasChosenRPS ? '‚úÖ Choice made' : '‚è≥ Waiting for choice...';
            }
        } else if (state.phase === 'action') {
            if (isTheirTurn) {
                return 'üéØ Your turn - Take action!';
            } else {
                return '‚è≥ Waiting for action...';
            }
        }
        return '‚è≥ Waiting...';
    }
    
    function makeRPSChoice(choice) {
        // Disable buttons immediately
        const rockBtn = getElement('rockBtn');
        const paperBtn = getElement('paperBtn');
        const officerBtn = getElement('officerBtn');
        if (rockBtn) rockBtn.disabled = true;
        if (paperBtn) paperBtn.disabled = true;
        if (officerBtn) officerBtn.disabled = true;
        
        fetch(`/game-action/${gameId}`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ type: 'rps', username: username, choice: choice })
        })
        .then(response => {
            if (!response.ok) throw new Error(`HTTP ${response.status}`);
            return response.json();
        })
        .then(data => {
            if (data.error) showError(data.error);
        })
        .catch(error => {
            showError('Failed to make choice: ' + error.message);
            // Re-enable buttons on error
            if (currentState && currentState.phase === 'rps' && currentState.turn === username) {
                if (rockBtn) rockBtn.disabled = false;
                if (paperBtn) paperBtn.disabled = false;
                if (officerBtn) officerBtn.disabled = false;
            }
        });
    }
    
    function makeAction(action) {
        // Disable buttons immediately
        const mortarBtn = getElement('mortarBtn');
        const shieldBtn = getElement('shieldBtn');
        const slicerBtn = getElement('slicerBtn');
        if (mortarBtn) mortarBtn.disabled = true;
        if (shieldBtn) shieldBtn.disabled = true;
        if (slicerBtn) slicerBtn.disabled = true;
        
        fetch(`/game-action/${gameId}`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ type: 'action', username: username, action: action })
        })
        .then(response => {
            if (!response.ok) throw new Error(`HTTP ${response.status}`);
            return response.json();
        })
        .then(data => {
            if (data.error) showError(data.error);
        })
        .catch(error => {
            showError('Failed to perform action: ' + error.message);
            // Re-enable buttons on error
            if (currentState && currentState.phase === 'action' && currentState.turn === username) {
                if (mortarBtn) mortarBtn.disabled = false;
                if (shieldBtn) shieldBtn.disabled = false;
                if (slicerBtn) slicerBtn.disabled = false;
            }
        });
    }
    
    function showGameOver(state) {
        clearInterval(statePollInterval);
        clearInterval(statusPollInterval);
        
        const opponent = state.players.find(p => p !== username);
        const playerWon = state.islands[username].parts > 0;
        
        const modal = getElement('gameOverModal');
        const title = getElement('gameOverTitle');
        const message = getElement('gameOverMessage');
        
        if (!modal || !title || !message) return;
        
        if (playerWon) {
            title.textContent = 'üéâ Victory!';
            title.style.color = '#00aaff';
            message.textContent = `You destroyed ${opponent}'s island! Congratulations!`;
        } else {
            title.textContent = 'üí• Defeat';
            title.style.color = '#ff4500';
            message.textContent = `${opponent} destroyed your island! Better luck next time!`;
        }
        
        modal.classList.remove('hidden');
    }
    
    // Keep user online status updated
    setInterval(() => {
        if (username) {
            fetch(`/user?q=${encodeURIComponent(username)}`)
                .catch(error => console.log('Status update failed:', error.message));
        }
    }, 30000);
    
    // Clean up on page unload
    window.addEventListener('beforeunload', () => {
        if (statePollInterval) clearInterval(statePollInterval);
        if (statusPollInterval) clearInterval(statusPollInterval);
    });
</script>
